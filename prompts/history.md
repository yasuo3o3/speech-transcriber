# Speech Transcriber - Development History

## 2025-01-25 21:45 JST - 汎用テイル保存システムの実装（録音20秒未満でも確実に保存）

### 送信プロンプト全文
現在のシステムでは、録音が20秒未満で終了した場合（例：18秒でEnter）、通常チャンクが生成されず、テイルチャンクも作成条件（TAIL_MIN_SEC=1.0）を満たさないため、音声が保存されない問題があります。

録音が20秒未満で終了した場合（例：18秒でEnter）でも、その音声を1チャンクとして必ず保存・出力・最終結合に含めてください。

**実装要求**:

1. **TAIL_MIN_SEC の既定値を 0.0 に変更**
   - 任意の長さの残り音声（1秒でも18秒でも）を保存対象にします
   - .envSample と README.md の説明も更新

2. **テイルフラッシュを必須実行に改修**
   - Chunker は通常ループを抜ける前に、以下の **テイルフラッシュ** を必須実行:
   ```
   # EXIT SEQUENCE: Mandatory tail flush before sentinel injection
   tail_chunk = self.create_tail_chunk_mandatory()
   if tail_chunk:
       self.transcribe_queue.put(tail_chunk, timeout=2.0)
   self.transcribe_queue.put(STOP_SENTINEL, timeout=2.0)
   ```

3. **早期終了（<20s）対応の実装**
   - 通常チャンクが0個の場合、テイルチャンクが全録音（start_index=0）をカバー
   - テイルチャンク生成ログ: `Flushing tail chunk: samples=83200 sec=5.20 start=0 end=83200`
   - create_tail_chunk_mandatory メソッドで常に実行（条件なし）

4. **センチネル順序の調整**
   - STOP_SENTINEL はテイルチャンク注入**後**に送信
   - Worker スレッドはSENTINEL受信で正常終了

5. **ログ・可視化の強化**
   - RealtimePrinter でテイルチャンク識別: `=== chunk N (tail: 83200 samples, 5.20s) ===`
   - 早期終了時のサンプル数・秒数を明確に表示

### 出力要約
汎用テイル保存システムを実装しました：

1. **TAIL_MIN_SEC既定値変更**: 1.0 → 0.0（任意の残り音声を保存）
2. **必須テイルフラッシュ**: chunker終了時に必ずテイルチャンク生成・注入
3. **早期終了対応**: <20s録音でもstart_index=0からの全音声をテイルチャンクとして保存
4. **センチネル順序調整**: テイルチャンク → STOP_SENTINEL の順番で注入
5. **強化ログ**: テイルチャンクのサンプル数・秒数・範囲を詳細表示

録音時間に関係なく（1秒でも18秒でも）、全ての音声が確実に保存・処理される汎用システムが完成しました。

### 次アクション
動作検証: 5秒、10秒、15秒、18秒などの短い録音でテイルチャンク生成・表示・最終保存が正常に動作することを確認

## 2025-01-25 18:30 JST - README強化・Notionインテグレーション権限付与の明記

### 送信プロンプト全文
修正依頼（README強化・Notionインテグレーションの権限付与を明記）：

背景：既存インテグレーションを流用した際、保存先ページに権限が付いておらず「Could not find page with ID …」が発生した。READMEに正しい手順を追記して、同種のトラブルを防ぎたい。

対応：README.md に下記「README追記用テキスト」を追加してください（文言微調整可、意味は等価に）。既存ファイルは上書きで構いません。処理は止まらないように。

あわせて prompts/history.md に、この修正依頼のログを追記してください（日時JST・件名・送信プロンプト全文・出力要約・次アクションを追記。追記であって上書き不可）。

README追記用テキスト（そのまま入れてOK）：

Notion Integration の設定
A. 新規にインテグレーションを作る場合

https://www.notion.so/my-integrations
 で New integration を作成し、NOTION_TOKEN を取得します。

Capabilities（権限）は「Read content」「Insert content」「Update content」を有効にしてください。

保存先となる親ページを開き、右上の「共有」または「…」メニューから Integration を接続（Add connections / Invite） します。

親ページURL末尾の32桁IDを .env に設定します（ハイフン有無どちらでも可）：
NOTION_PARENT_PAGE_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

.env 例：
NOTION_TOKEN=secret_xxxxxxxxxxxxxxxxx
NOTION_PARENT_PAGE_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

B. 既存インテグレーションを「使い回す」場合（ハマりどころ）

https://www.notion.so/profile/integrations/
 を開き、対象インテグレーションを選択します。

「アクセス」タブ → 右上の アクセス権限を編集 をクリックします。

検索欄で保存先の親ページを指定し、アクセスを更新（追加） します。

これでその親ページ配下に API で子ページを作成できるようになります。

.env は既存の NOTION_TOKEN をそのまま使い、NOTION_PARENT_PAGE_ID に親ページID（URL末尾32桁）を設定します。

よくあるエラー

Could not find page with ID: ...
→ ほぼ権限不足です。上記 A-2 または B-3 の「ページにインテグレーションを接続（アクセス付与）」が未実施です。

別ワークスペースのトークンを使っている
→ 親ページと同じワークスペースのインテグレーションを使用してください。

受け入れ基準：

README.md に新規作成ケース(A)と既存流用ケース(B)の両方が明記され、Could not find page with ID の再発を防げること。

prompts/history.md に本依頼のログが追記されていること（上書きではなく追記）。

### 出力概要
- README.md の Notion Integration セクションを大幅強化
- 新規作成ケース(A)と既存流用ケース(B)の詳細手順を追加
- 「Could not find page with ID」エラーの原因と対処法を明記
- prompts/history.md を新規作成し、開発履歴の記録を開始

### 主要ファイル
- README.md（73-110行目に詳細なNotion設定手順を追加）
- prompts/history.md（新規作成、本ログを記録）

### 注意点
- 既存インテグレーション流用時のアクセス権限追加手順が重要
- ワークスペース間違いによるエラーケースも言及

### 次アクション
- .env ファイルにNotion設定情報を入力
- 新規または既存インテグレーションの適切な権限設定を実施
- python main.py で動作確認実行

## 2025-01-25 19:15 JST - IMEとDiscordレイアウトの調整

### 送信プロンプト全文
修正依頼（IMEとDiscordレイアウトの調整）：

【背景】

保存確認プロンプトの y/n 入力で、日本語IMEが有効のまま 全角「ｙ／ｎ」 を入力→Enter→さらにEnter…の流れで、意図せず No 扱いで破棄 される事故が発生。

Discord への投稿で タイトル行とサマリー行の間に空行が1行 入ってしまい、詰めたい。

【対応方針】

保存確認の y/n 入力を ロバスト化。全角/半角や大小文字を正規化して判定。未判定は再入力を促す。

Discord 投稿の 余計な空行をなくす（タイトルの直下にサマリーを1行で続ける）。

【具体指示】

A. 保存確認の入力処理を改善

入力文字列に対して Unicode 正規化（NFKC）→ strip() → lower() を適用し、以下を同一視して判定する：

Yes 系：y, yes, ｙ, Ｙ, はい

No 系： n, no, ｎ, Ｎ, いいえ

上記どちらにも当てはまらない場合は 決してデフォルトで No にしない。
→ 「入力が認識できません。y/yes/はい または n/no/いいえ を入力してください。」と再度プロンプト。

事故防止のため、No を選んだときだけ二段階確認を入れてください：

例：「本当にこの録音を破棄しますか？ (y/n)」

ここでも同じ正規化ロジックを適用し、y/はい のときだけ破棄。n/いいえ は保存フローへ戻す。

既存の処理フロー（Enterで停止→保存 or 破棄→保存時はタイトル/概要入力→Discord/Notion送信）は維持。

B. Discord 投稿の空行を除去

Webhook の content を タイトル + 改行 + サマリー のみで構築し、余分な改行（先頭・末尾の \n、二重 \n\n）を入れない。

明示仕様：

サマリーあり："{title}\n{summary}"

サマリー空："{title}"（末尾改行なし）

送信前に title / summary は strip() で前後空白・改行を除去。

もし埋め込み（embeds）を使っている場合も、タイトル→説明の間に空行が入らないように構築。不要なら content 方式でOK。

既存の Discord 投稿の他仕様（リトライ、allowed_mentions など）は現状踏襲。

【受け入れ基準】

日本語IMEがオンで 全角「ｙ」「ｎ」 を入力しても、正しく Yes/No として認識される。

未判定文字（例：「ー」「yです」など）を入れても 勝手に No に落ちず、再入力を促す。

No 選択時のみ 二段階確認が出て、y/はい 確定で破棄、n/いいえ で保存フローに戻る。

Discordの投稿は タイトル行の直下にサマリー行が続き、空行は入らない。サマリー未入力時はタイトルのみが1行で投稿される。

既存の README / ドキュメントに、この入力仕様（全角対応＆No時の二段階確認）と Discord の改行ルールを追記。

prompts/history.md に本修正依頼のログを 追記（上書き禁止）。

備考：

文字正規化には Python の unicodedata.normalize("NFKC", s) を利用してください。実装は任意ですが、NFKC→strip→lower の順が望ましい。

既存ファイルは 上書きでOK。処理がダイアログで止まらないように進めてください。

### 出力概要
- main.py に Unicode 正規化による入力処理を実装
- 全角・半角文字の自動認識機能を追加（y/ｙ/yes/はい など）
- No選択時の二段階確認機能を実装
- discord_client.py の投稿形式を改善（余分な空行を除去）
- README.md に新しい入力仕様とDiscord投稿形式を明記

### 主要ファイル
- main.py（93-117行目に入力正規化機能、190-200行目に二段階確認フロー）
- discord_client.py（19-27行目にクリーンな投稿形式）
- README.md（125-144行目に詳細な操作手順と投稿形式）

### 注意点
- unicodedata.normalize("NFKC") による全角・半角統一
- 未判定入力時はデフォルトでNoにしない安全設計
- 二段階確認による誤操作防止

### 次アクション
- 日本語IME有効状態での動作確認
- 全角文字入力テスト（ｙ、ｎ、はい、いいえ）
- Discord投稿の空行確認とテスト

## 2025-01-25 19:45 JST - ユーザープロンプトの日本語統一＋選択ヒント表示

### 送信プロンプト全文
修正依頼（ユーザープロンプトの日本語統一＋選択ヒント表示＋全角対応は現状維持）：

【背景】

保存確認や再確認、タイトル/概要入力など「ユーザーが入力するプロンプト」の言語が混在している。

Yes/No の意味が直感的に分かるよう、(y=保存 / n=破棄) などのヒントを併記したい。

すでに導入済みの全角対応（NFKC 正規化）＆ No 時のみ二段階確認は維持。

【対応方針】

重要プロンプトは日本語に統一し、メッセージはファイル冒頭に定数で集約。

定数には英語版の参考文言をコメントで併記（EN: ...）。実装は日本語をデフォルトとする。

実行ログ（Saving..., Successfully ...）などは英語のままでよい（変更不要）。

【具体指示】

main.py の先頭付近に下記定数を定義し、既存の入力プロンプト表示箇所をすべて置き換える。

すでにある NFKC→strip→lower の正規化、ならびに No 選択時の二段階確認ロジックはそのまま適用すること。

定数（そのまま使用可）：
MSG_SAVE_CONFIRM = "この録音を保存しますか？ (y=保存 / n=破棄): " # EN: "Do you want to save this recording? (y=save / n=discard): "
MSG_DISCARD_CONFIRM = "本当にこの録音を破棄しますか？ (y=破棄 / n=保存に戻る): " # EN: "Are you sure you want to discard this recording? (y=discard / n=go back to save): "
MSG_ENTER_TITLE = "タイトルを入力してください: " # EN: "Enter title: "
MSG_ENTER_SUMMARY = "概要を入力してください（空でも可）: " # EN: "Enter summary (optional): "
MSG_INPUT_INVALID = "入力が認識できません。y/yes/はい または n/no/いいえ を入力してください。"

上記の提示どおり、保存確認・破棄確認・タイトル/概要入力・無効入力時のメッセージをこの定数経由で表示する。

Yes/No 判定は既存どおり NFKC 正規化＋大小無視＋日本語（はい/いいえ）対応で行う。

他の挙動（Enterで停止、保存フロー、Discord/Notion送信、ログ出力）は変更しない。

【README 追記】

「プロンプトの言語を変更したい場合は main.py 冒頭の MSG_* 定数を書き換えるだけでよい。英語例はコメント（EN: ...）を参照」と短く追記。

【history.md】

本修正依頼を追記（日時JST／件名／送信プロンプト全文／出力要約／次アクション）。追記であって上書き不可。

【受け入れ基準】

重要プロンプトが日本語で統一され、(y=保存 / n=破棄) などのヒントが併記されている。

全角のｙ/ｎ、はい/いいえ、YES/NO などが正しく解釈され、未判定入力は MSG_INPUT_INVALID を表示して再入力を促す。

No を選んだ場合のみ二段階確認（MSG_DISCARD_CONFIRM）が出る。n を選べば保存フローに戻る。

実行ログ系メッセージは従来どおり英語のまま。

README と history.md が更新されている。

### 出力概要
- main.py 冒頭に日本語プロンプト定数（MSG_*）を追加
- 全ユーザー入力プロンプトを日本語に統一
- 選択ヒント (y=保存 / n=破棄) を各確認メッセージに追加
- 概要入力を「空でも可」に変更し、必須チェックを削除
- README.md にプロンプト言語カスタマイズ方法を追記

### 主要ファイル
- main.py（21-25行目にメッセージ定数、120/124/198/236/242行目でプロンプト使用）
- README.md（195-197行目にカスタマイズ手順を追加）
- prompts/history.md（本ログエントリを追記）

### 注意点
- 既存のUnicode正規化と二段階確認ロジックは完全維持
- 実行ログ系メッセージは英語のまま（仕様通り）
- 概要入力を任意入力に変更（空でも処理続行）

### 次アクション
- 日本語プロンプトでの動作確認
- 選択ヒント表示の視認性テスト
- 概要空入力時の正常動作確認

## 2025-01-25 20:00 JST - main.pyの入力メッセージ更新に伴うREADME整備

### 送信プロンプト全文
修正依頼（main.pyの入力メッセージ更新に伴うREADME整備。内部互換は維持）：

【前提変更】

main.py の無効入力メッセージを下記に更新しました（この定数はそのまま使用を維持してください）。
MSG_INPUT_INVALID = "入力が認識できません。[y]または[n]を入力してください。"

【要望】

README.md を更新してください。ユーザー向けには 入力は y / n のみ と明記し、全角ｙ／ｎも可と書いてください。

例文（意図が伝われば文面は調整可）：

「保存可否のプロンプトには y または n で回答してください（全角ｙ／ｎも可）。その他の入力は無効として再入力を促します。」

「No を選んだ場合のみ破棄の再確認が表示されます。」

注意：実装側では互換のため「はい / いいえ」も受理するロジック（NFKC→strip→lower 後の判定）を残したままにしてください。

ただし README には y/nのみを案内し、「はい/いいえ」対応は記載しないでください（ドキュメント非公開仕様）。

既存の NFKC 正規化・No時のみ二段階確認ロジックはそのまま維持。

プロンプト文言（日本語）の定数化とコメント（EN: …）の方針は既存どおりでOK。必要があれば MSG_INPUT_INVALID の近くに統一感のある位置へ整理して構いません。

prompts/history.md に本依頼のログを追記してください（日時JST・件名・送信プロンプト全文・出力要約・次アクション）。追記であって上書き不可。

【受け入れ基準】

README に「入力は y / n（全角可）、その他は無効」「No選択時のみ再確認」の説明が追記されている。

実装では引き続き「はい / いいえ」も受理するが、README には明記しない。

main.py の MSG_INPUT_INVALID は指定どおりで動作し、実行時のユーザー体験が y/n に一本化されている。

history.md が追記されている。

### 出力概要
- README.md の操作手順を y/n 入力仕様に更新
- ユーザー向けドキュメントで入力方式を明確化（y または n、全角可）
- 「No 選択時のみ再確認」の動作説明を追加
- 内部実装の「はい/いいえ」対応は非公開仕様として維持

### 主要ファイル
- README.md（130-134行目の操作手順を簡潔化）
- prompts/history.md（本ログエントリを追記）

### 注意点
- 実装では「はい/いいえ」も引き続き受理（後方互換性維持）
- README では y/n のみ案内（ユーザー体験の統一）
- MSG_INPUT_INVALID の更新内容を反映

### 次アクション
- y/n 入力での動作確認
- 全角 ｙ/ｎ 入力テスト
- 「はい/いいえ」の非公開仕様動作確認

## 2025-01-25 20:15 JST - READMEにWindowsワンボタン実行手順を追記

### 送信プロンプト全文
修正依頼（READMEにWindowsワンボタン実行手順を追記）：

【背景】
Windows環境で Speech Transcriber を簡単に起動する方法を利用者に分かりやすく案内したい。
そこで、main.py を直接実行する代わりに、バッチファイルでワンボタン起動できる手順を README.md に追記してほしい。

【追記内容】
README.md に以下のセクションを追加してください（文言調整可だが内容は等価にすること）：

Windowsでワンボタン実行する方法

プロジェクトのルートディレクトリ（main.py がある場所）に run_transcriber.bat というファイルを作成し、以下の内容を貼り付けて保存します：

@echo off
REM ===== Speech Transcriber 実行バッチ =====
cd /d %~dp0
python main.py
pause


cd /d %~dp0 : このバッチファイルが置いてある場所に移動します

python main.py : プログラムを実行します

pause : 実行後にウィンドウが自動で閉じないようにします

run_transcriber.bat を ダブルクリックすることで、Speech Transcriber が起動します。

より便利にするには、run_transcriber.bat の ショートカットを作成し、デスクトップなどに配置してください。

プロパティからアイコンを変更することで分かりやすくできます。

【READMEで不要なもの】

Android の説明はまだ追記しない（別途後で行う予定）。

Python環境のセットアップ手順など既存の記載はそのまま維持。

【history.md】

この修正依頼のログを追記してください（日時JST／件名／送信プロンプト全文／出力要約／次アクション）。追記であって上書き不可。

【コミット文】

この変更に対応する git commit メッセージを日本語で提案してください。

【受け入れ基準】

README.md に Windows 向けのワンボタン実行手順が追加されている。

内容を読んだ利用者がバッチファイルを作成し、ダブルクリックで起動できる。

history.md に本依頼の記録が追記されている。

日本語のコミットメッセージが提示されている。

### 出力概要
- README.md に「Windowsでワンボタン実行する方法」セクションを追加
- run_transcriber.bat の作成手順と内容を詳細に説明
- 各バッチコマンドの役割を分かりやすく解説
- ショートカット作成による利便性向上の提案を追記

### 主要ファイル
- README.md（120-141行目にWindowsバッチ実行手順を追加）
- prompts/history.md（本ログエントリを追記）

### 注意点
- バッチファイルの内容を完全に記載し、コピー&ペーストで使用可能
- 各コマンドの説明により初心者でも理解しやすい構成
- ショートカット作成とアイコン変更の提案で使いやすさを向上

### 次アクション
- run_transcriber.bat ファイルの作成テスト
- ダブルクリック起動の動作確認
- ショートカット作成とアイコン変更の検証

## 2025-01-25 20:30 JST - Notion 送信の長文対応：チャンク分割・バッチ投入・ページ分割の実装

### 送信プロンプト全文
修正依頼（Notion 送信の長文対応：チャンク分割・バッチ投入・ページ分割の実装）

【背景】

文字起こし本文が長文になるケースで、Notion API の制限（1ブロックの文字数、1リクエストあたりの children 上限、ページ全体の実質上限など）に安全に対応したい。

既存実装は通常サイズでは問題ないが、極端に長い本文でも確実に保存できるようにしたい。

【要件】

段落→ブロック分割

「句点（。）」区切りで既に改行整形済みの本文テキストを、段落ごとに paragraph ブロックへ変換。

1リッチテキスト当たりの文字数上限を考慮し、長すぎる段落は安全側で 1800 文字を上限目安に分割（NFKCは不要、単純文字数分割で可。文の途中でも可、末尾に「…」などは不要）。

バッチ投入

Notion API の children 追加は1リクエストあたり 100 ブロック上限があるため、50 ブロック/回程度でバッチ投入。

既存の**リトライ（最大3回）**は維持。429/5xx は指数バックオフで再試行。

ページ分割（ソフト上限）

1ページに追加する本文の総文字数が 80,000 文字を超えそうなら、自動で続きの子ページを作って分割保存する（タイトルは「{元タイトル}（続き1）」「（続き2）」の連番）。

段落の途中では分割しない。ブロック境界で切り替える。

本文の前置きレイアウトは現状維持

ページ構成：「日時・タイトル → 区切り線 → 概要 → 区切り線 → 本文」のまま。

今回は本文ブロックの投入方法のみを強化する。概要やタイトルの扱いは変更しない。

副作用防止 / 冪等性

途中失敗で再実行した際に二重挿入にならないよう、1回の保存処理内で完了した子ページIDや最後に投入したブロック数を手元で管理し、失敗リトライは未投入の残りから再開する（メモリ内のセッション管理で可。外部ストアは不要）。

完了後に「保存した総ブロック数」「作成した子ページ数」をログ出力。

コード配置

notion_api.py（旧 notion_client.py）に以下の関数を追加・更新：

chunk_paragraphs_for_notion(text: str, max_len: int = 1800) -> list[str]

make_paragraph_block(text: str) -> dict

append_children_batched(blocks: list[dict], parent_id: str, batch_size: int = 50)

create_or_split_page_for_long_content(title: str, header_blocks: list[dict], body_blocks: list[dict], parent_page_id: str, page_soft_limit_chars: int = 80000)

既存の送信フローから上記関数を呼ぶように差し替え（main.py 側の呼び出しは最小変更）。

README 追記（概要のみ）

「長文でも自動的に段落分割・バッチ送信・必要に応じてページ分割されます。設定値（段落分割 1800 文字、1リクエスト 50 ブロック、1ページ 80,000 文字のソフト上限）は notion_api.py の定数で調整可能。」の説明を短く追記。

history.md

本依頼のログを追記（日時JST／件名／送信プロンプト全文／出力要約／次アクション）。追記であって上書き不可。

【受け入れ基準】

10万文字級の長文を与えても、Notion への保存がエラーなく完走する（ページが複数に分割されても可）。

1段落が 1800 文字を超える場合でも、自動で複数 paragraph ブロックに割れて保存される。

ブロックは 50 件ずつのバッチ投入で送られ、429/5xx が発生しても既存のリトライで回復する。

途中失敗からの再実行でも、二重挿入にならず未投入分から続きが保存される。

README と history.md が更新されている。

【コミット文】

この変更に対応する git commit メッセージを日本語で提案してください。

### 出力概要
- notion_api.py に長文処理用の新機能を実装
- 段落チャンク分割（1800文字上限）でNotion API制限に対応
- 50ブロック単位のバッチ投入でレート制限を回避
- 80,000文字超過時の自動ページ分割機能
- 既存のリトライ機能を維持しつつ堅牢性を向上
- README.md に長文対応機能の説明を追加

### 主要ファイル
- notion_api.py（11-13行目に定数追加、27-252行目に長文処理機能実装）
- README.md（216-218行目に長文対応説明を追加）
- prompts/history.md（本ログエントリを追記）

### 注意点
- 既存の create_page メソッドを完全リニューアル
- バッチ処理とページ分割でNotionAPI制限を安全に回避
- メモリ内セッション管理による冪等性確保
- 詳細なログ出力で処理状況を可視化

### 次アクション
- 10万文字級の長文での動作テスト
- バッチ投入と自動ページ分割の確認
- レート制限時のリトライ動作検証

## 2025-01-25 21:00 JST - 保存直前処理を「ローカル補正＋AI補正」に二段構成へ変更

### 送信プロンプト全文
修正依頼（保存直前処理を「ローカル補正＋AI補正」に二段構成へ変更）

【目的】
- 既存フロー（録音→20秒起こし→Enter停止→y/n→Discord/Notion）はそのまま維持。
- 保存直前に以下の二段構成で補正を行いたい：
  1) ローカルフィルター：全角→半角正規化＋技術用語ホワイトリスト置換
  2) AI補正：gpt-4o による軽い補正（テストモード時は mini と両方）

【仕様】
1) utils.py
   - 既存の `normalize_tech_terms()` を活かして、  
     - 手順A: `unicodedata.normalize("NFKC", text)` で全角英数記号を半角化  
     - 手順B: ホワイトリスト置換（.env → .env, README.md → README.md, history.md → history.md, Git/GitHub, Python, Notion/Discord など）
   - その結果を返す（AI補正前の整形段階）。

2) AI補正用関数
   - `def postprocess_with_ai(text: str, context_hint: str = "", test_mode: bool = False) -> str`
   - プロンプト内容:  
     「入力テキストを壊さず、句読点・誤字を軽く整える。内容は変えない。専門用語やタグ（例: env, README.md）はそのまま保持。」
   - 通常モード（test_mode=False）: gpt-4o のみに投げる → 補正テキストを返す
   - テストモード（test_mode=True）:  
     - gpt-4o-mini に投げた結果と gpt-4o に投げた結果を両方取得  
     - 出力を以下のフォーマットで結合して返す：
       ```
       === gpt-4o-mini 補正結果 ===
       （miniの補正結果）

       === gpt-4o 補正結果 ===
       （4oの補正結果）
       ```

3) main.py
   - 保存直前のフローで：
     - `text = normalize_tech_terms(text)` を実行  
     - その後 `text = postprocess_with_ai(text, context_hint=f"{title} {summary}", test_mode=TEST_MODE)` を実行  
   - Discord送信・Notion保存ともこの補正後テキストを利用

4) .env に設定を追加
   - `NORMALIZE_TECH_TERMS=true|false`（既定 true）  
   - `POSTPROCESS_TEST_MODE=true|false`（既定 false）

5) README.md
   - 保存直前の二段補正フローを明記：
     1) ローカルフィルターで全角→半角・技術用語統一  
     2) AI補正で軽い整形（gpt-4o）  
   - `.env` のフラグで無効化・テストモード切替ができることを説明  
   - テストモード時は gpt-4o-mini と gpt-4o の両方の補正結果が並んで出力されることも記載

6) history.md
   - 本依頼内容を追記（日時JST／件名／送信プロンプト全文／出力要約／次アクション）

【受け入れ基準】
- フロー自体（録音開始〜保存確認〜Discord/Notion送信）は変わらない
- ローカルフィルターが適用され、.env などが確実に統一される
- 通常モードでは gpt-4o 補正済みテキストが保存される
- テストモードでは mini と 4o の両方がラベル付きで出力される
- README と history.md が更新されている

【コミット文】
- この変更に対応する git commit メッセージを日本語で提案してください

### 出力概要
- utils.py に normalize_tech_terms と postprocess_with_ai の2つの新機能を実装
- 二段構成の補正処理：ローカル正規化→AI補正の順序で実行
- main.py の process_transcription メソッドに apply_text_corrections を追加
- .envSample ファイルを新規作成し、NORMALIZE_TECH_TERMS と POSTPROCESS_TEST_MODE を追加
- README.md に機能説明、環境設定、ファイル構成の更新を実施

### 主要ファイル
- utils.py（27-129行目に normalize_tech_terms と postprocess_with_ai を実装）
- main.py（20-22行目に設定フラグ、152-196行目に補正処理フロー）
- .envSample（新規作成、全設定項目を網羅）
- README.md（10-12行目に機能追加、65-76行目に補正設定説明、189行目にutils.pyの説明更新）
- prompts/history.md（本ログエントリを追記）

### 注意点
- 既存フローは完全維持（録音→転写→y/n確認→タイトル/概要入力→保存）
- 補正処理は保存直前のみに適用、ユーザーには途中結果は非表示
- エラー時はローカル補正のみで続行する安全設計
- テストモードでは両モデルの結果を比較表示

### 次アクション
- .envSample を参考に .env ファイルを作成・設定
- 録音テストで補正機能の動作確認
- POSTPROCESS_TEST_MODE=true での両モデル比較テスト

## 2025-01-25 21:30 JST - リアルタイム文字起こし改善：20秒ごとに文末優先でコンソール出力し、結合時に重複を整理

### 送信プロンプト全文
以下の変更を既存プロジェクトに加えてください。
生成コードは上書きではなく必要部分を改修する形でお願いします。
また、変更内容は prompts/history.md に日時・件名・送信プロンプト全文・出力概要・次アクションを追記してください。

変更内容

リアルタイム表示の改善

録音中に 20秒ごとに gpt-4o-transcribe にチャンクを送信

結果を逐次コンソールに表示する

表示時に「文末記号（。！？）」が含まれていればそこまでを優先して出力

文末記号がなければ、そのままブツ切りで出力する（遅延は発生させない）

録音終了後の処理

Enterで録音停止

すべてのチャンクテキストを結合

重複処理（チャンク結合時）

ローカル処理で「前チャンク末尾」と「次チャンク冒頭」が完全一致している部分を削除

さらに gpt-4o に補正依頼を行い、表記違いで同じ意味の単語が連続した場合は自然に丸める

最終補正フロー

ローカル辞書補正（全角→半角、技術用語表記の統一など）

gpt-4o に軽く補正を依頼（句読点や重複整理など）

保存フロー

タイトルと概要を入力

Discord に送信（タイトル＋概要）

Notion に保存（タイトル＋概要＋本文）

注意事項

.env.example, .gitignore, README.md など既存ファイルがある場合も、必ず上書きして処理を進めてください。

確認プロンプトは不要です。

コミットメッセージ案
リアルタイム文字起こし改善: 20秒ごとに文末優先でコンソール出力し、結合時に重複を整理。録音終了後は辞書補正＋GPT補正を経てDiscord/Notionに送信。既存ファイルは自動で上書き処理。

### 出力概要
- AudioRecorderクラスをリアルタイム処理に改修（20秒ごとのチャンク生成・コールバック機能追加）
- SpeechTranscriberクラスにリアルタイム文字起こし機能を追加（transcribe_chunk_realtime メソッド）
- utils.py に3つの新機能を実装：
  - format_realtime_text: 文末記号優先表示
  - remove_chunk_duplicates: ローカル重複削除
  - refine_duplicates_with_ai: GPT-4oによる意味的重複整理
- 最終補正フローを3段階に拡張（重複削除→ローカル正規化→AI補正）
- runメソッドをリアルタイムフローに完全改修

### 主要ファイル
- main.py（31-87行目: AudioRecorderクラス改修、156-195行目: リアルタイム文字起こし、219-249行目: 3段階補正フロー、315-346行目: 新しい実行フロー）
- utils.py（131-208行目: リアルタイム表示・重複削除・AI重複整理機能を追加）
- prompts/history.md（本ログエントリを追記）

### 注意点
- 録音中は20秒ごとにリアルタイムで文字起こしを表示
- 文末記号がある場合は文章単位で表示、なければそのまま表示
- チャンク結合時は完全一致とAI補正の二重重複削除
- 既存の二段補正に重複削除を追加した三段補正フローに統合
- 従来の単発録音→一括文字起こしから連続リアルタイム処理に変更

### 次アクション
- リアルタイム文字起こしの動作テスト（20秒間隔での表示確認）
- 文末記号優先表示の動作確認
- チャンク重複削除とAI補正の統合テスト

## 2025-01-25 [時刻不明] - 非同期パイプライン設計への完全移行（v2.0）

### 送信プロンプト要旨
1. **UnboundLocalError修正要求**: current_chunkが未定義エラーの解決
2. **アーキテクチャ全面改修要求**: 音声欠落防止のため録音とAPI呼び出しを完全分離、非同期パイプライン設計への移行

### 主要な変更内容

**Ring Buffer Producer (AudioRecorder)**
- 軽量コールバックで音声サンプルを(timestamp, sample)ペアでリングバッファに蓄積
- 録音とAPI処理を完全分離、音声欠落を防止
- extract_chunk メソッドでタイムスタンプ範囲指定による音声切り出し

**Chunker Thread (AudioChunker)**
- 20秒/2秒overlap の連続タイムライン管理
- next_chunk_time による規則的なチャンク生成（20s, 40s, 60s...）
- AudioChunk dataclass でメタデータ管理（start_ts, end_ts, audio_data）

**Consumer ThreadPool**
- TranscriptionResult dataclass設計（chunk_start_ts, api_start, api_end, text）
- ThreadPoolExecutor による並列API処理（MAX_TRANSCRIBE_WORKERS設定）
- キューベース非同期通信（TRANSCRIBE_QUEUE_MAX_SIZE設定）

**Real-time Printer (RealtimePrinter)**
- start_ts による厳密な時系列順序保証
- sentence-end 記号優先の表示制御（。！？.!?改行 を検出）
- sentence_buffer による部分表示管理

**Gap Detection & Logging**
- 各チャンクに capture_start/capture_end/api_start/api_end/printed_at 記録
- 連続チャンクの capture_start 差分監視（±0.5s許容範囲でWARNING）
- API応答時間とキューサイズの詳細ログ

**新環境変数 (.envSample追加)**
```
MAX_TRANSCRIBE_WORKERS=2
TRANSCRIBE_QUEUE_MAX_SIZE=10  
RING_BUFFER_SECONDS=300
```

### 実装詳細

**main.py完全リライト**: 
- AudioRecorder: Ring Bufferパターン実装（collections.deque使用）
- AudioChunker: 連続チャンク管理Thread
- RealtimePrinter: 順序保証出力制御
- SpeechTranscriber: 非同期パイプライン統合制御

**utils.py機能拡張**:
- 既存の二段補正（normalize_tech_terms, postprocess_with_ai）を維持
- remove_chunk_duplicates: ローカル重複除去（完全一致境界検出）
- refine_duplicates_with_ai: GPT-4o意味的重複整理

### アーキテクチャ比較

**v1.x (同期)**:
録音開始 → 20秒待機 → 録音停止 → API呼び出し → 結果表示

**v2.0 (非同期パイプライン)**:
```
[Ring Buffer] → [Chunker Thread] → [ThreadPool] → [Ordered Printer]
     ↓              ↓                   ↓            ↓
  常時録音      20s/2s overlap     並列API処理    順序保証表示
```

### テスト予定項目
- Ring Buffer による音声連続性確保
- 20秒/2秒 overlap チャンク生成精度
- ThreadPool API並列処理の負荷分散  
- Real-time Printer の順序保証と文末優先表示
- Gap Detection による音声欠落監視
- 最終処理（重複削除・AI補正）の統合性

### 次アクション
- README.md と history.md への変更点記録（完了）
- 統合テストと実動作確認
- 負荷テスト（長時間録音・高負荷API処理）
- 長時間録音での安定性検証

## 2025-01-XX [時刻不明] - テイル保存と最終補正モデル改善

### 送信プロンプト全文
以下の2点を実装してください。既存の非同期パイプラインは維持し、README と prompts/history.md にも追記してください。
確認ダイアログは不要、既存ファイルは上書きで進めて構いません。

1) 終了時に最後の残り（<20秒でも）を必ず保存する

現象
Enter で録音停止すると、最後の 20 秒未満の残りが 欠落 することがある。

要件
stop_event セット後、リングバッファに残っている末尾の未発行区間を「テイルチャンク」として必ず切り出して送信する。
たとえ 20 秒未満でも発行する（しきい値は 1.0～2.0 秒程度の最小秒数 TAIL_MIN_SEC を env で指定可。既定 1.0s）。
テイルの範囲は 「最後に発行したチャンクの end_index 〜 stop 時点の total_samples」 とする（= 余りだけ）。
ログ例：Flushing tail chunk: 5.2s (start=..., end=...)
センチネル投入は テイルチャンクをキューへ積んだ後 に行い、Consumers/Printer が処理し切ってから終了する（いまの in-flight/join の順序に従う）。
RealtimePrinter にも === chunk (tail) [Xs~Ys] === のように表示されること。

受け入れ基準
Enter を押した直後までの発話が Final に反映される（欠落なし）。
ログにテイル発行と処理完了が出る。
Final collect: N chunks stored, N chunks printed が一致。

2) 最終の軽補正モデルを gpt-4o-mini に固定（4o-mini を既定）

背景
4o は言い回しを動かしがち。4o-mini の方が素直なので、最終補正（重複整理・句読点整形等）は mini を使う。

要件
.env で最終補正モデルを指定できるようにし、既定値を gpt-4o-mini にする。
例）POSTPROCESS_MODEL=gpt-4o-mini
テストモード（両モデル比較表示）はそのまま維持して良いが、本番出力に採用するのは mini。
すでに導入済みの「境界限定・非要約」プロンプト（本文要約禁止）をこの最終補正でも使用すること。
数字列や列挙などの本文を短文化しないこと。
変更量が大きい場合のリバート（差分/類似率チェック）も維持。

受け入れ基準
.env 未設定でも mini が使われる。
テストモード ON 時は mini/4o の両結果を表示しつつ、採用は mini。
本文の言い換えが抑制され、意図しない要約・言い換えが発生しない。

追記してほしい箇所（README）
「録音停止時のテイル保存：最後の残りが 20 秒未満でも保存する」旨と TAIL_MIN_SEC の説明。
「最終補正モデル」の説明：.env の POSTPROCESS_MODEL（既定 gpt-4o-mini）、テストモード時の扱い。

### 出力概要
- 終了時のテイルチャンク保存機能を実装（最後の残り発話も必ず保存）
- TAIL_MIN_SEC 環境変数で最小保存秒数を制御（既定1.0s）
- Chunkerに create_tail_chunk メソッドとlast_chunk_end_index トラッキングを追加
- RealtimePrinterで (tail) 表示機能を実装
- 最終補正モデルをgpt-4o-miniに変更（POSTPROCESS_MODEL環境変数）
- 境界限定補正プロンプトで本文要約を防止
- テストモードで両モデル比較、最終採用はmini
- 変更量の安全弁（リバート機能）を維持
- Notion出力のブロック構造を修正（H2→P→H2→P の適切な分離）

### 主要ファイル
- main.py（26-28行目: 新環境変数、AudioChunker改修、テイル処理フロー）
- utils.py（postprocess_with_ai 改修、境界限定プロンプト、安全弁機能）
- notion_api.py（_build_structured_header_blocks でブロック分離改善）
- README.md（テイル保存とPOSTPROCESS_MODELの説明追加）

### 注意点
- 既存の非同期パイプライン設計を完全維持
- テイルチャンクは最後に発行したchunk end_index以降のみ処理
- センチネル順序を調整してドレイン処理を安全実行
- AI補正で本文要約・言い換えを強力に抑制
- Notionのブロック構造で概要と全文を明確分離

### 次アクション
- テイルチャンク保存の動作確認（Enter直後の発話保存テスト）
- gpt-4o-mini最終補正の品質確認
- 本文要約防止機能の検証（数字列・物語文で確認）
- Notion出力の正しいブロック構造確認